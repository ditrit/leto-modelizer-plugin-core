<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/draw/DefaultDrawer.js | leto-modelizer-plugin-core</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Library that contains all models for modelling tools in Leto&apos;s projects."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="leto-modelizer-plugin-core"><meta property="twitter:description" content="Library that contains all models for modelling tools in Leto&apos;s projects."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/ditrit/leto-modelizer-plugin-core"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#assets-actions">assets/actions</a><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-actionIcons">actionIcons</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#draw">draw</a><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/draw/DefaultDrawer.js~DefaultDrawer.html">DefaultDrawer</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#error">error</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/error/ParseError.js~ParseError.html">ParseError</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#metadata">metadata</a><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/metadata/DefaultMetadata.js~DefaultMetadata.html">DefaultMetadata</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#models">models</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/models/Component.js~Component.html">Component</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/models/ComponentAttribute.js~ComponentAttribute.html">ComponentAttribute</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/models/ComponentAttributeDefinition.js~ComponentAttributeDefinition.html">ComponentAttributeDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/models/ComponentDefinition.js~ComponentDefinition.html">ComponentDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/models/ComponentDrawOption.js~ComponentDrawOption.html">ComponentDrawOption</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/models/ComponentLink.js~ComponentLink.html">ComponentLink</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/models/ComponentLinkDefinition.js~ComponentLinkDefinition.html">ComponentLinkDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/models/DefaultData.js~DefaultData.html">DefaultData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/models/DefaultPlugin.js~DefaultPlugin.html">DefaultPlugin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/models/FileInformation.js~FileInformation.html">FileInformation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/models/FileInput.js~FileInput.html">FileInput</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parser">parser</a><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/parser/DefaultParser.js~DefaultParser.html">DefaultParser</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#render">render</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/render/DefaultRender.js~DefaultRender.html">DefaultRender</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/draw/DefaultDrawer.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import * as d3 from &apos;d3&apos;;
import nunjucks from &apos;nunjucks&apos;;
import ComponentDrawOption from &apos;../models/ComponentDrawOption&apos;;
import actionIcons from &apos;../assets/actions/actionIcons&apos;;
import ComponentLink from &apos;../models/ComponentLink&apos;;

/**
 * Class that draws a component in a graphical representation.
 * @interface
 */
class DefaultDrawer {
  /**
   * Default constructor
   * @param {DefaultData} pluginData - Plugin data storage.
   * @param {Object} [resources=null] - Object that contains resources.
   * @param {Object} [events] - Events list.
   * @param {Function} [events.SelectEvent.next] - Function to emit selection event.
   * @param {Function} [events.UpdateEvent.next] - Function to emit update event.
   * @param {String} [rootId=&quot;root&quot;] - Id of HTML element where we want to draw.
   * @param {Object} [options={}] - Rendering options.
   * @param {Number} [options.width=1280] - Render svg viewbox width.
   * @param {Number} [options.height=1280] - Render svg viewbox height.
   * @param {Number} [options.minWidth=230] - Minimum width of a component.
   * @param {Number} [options.minHeight=50] - Minimum height of a component.
   * @param {Number} [options.padding=30] - Padding around a component.
   * @param {Number} [options.margin=6] - Component margin thickness.
   * @param {Number[]} [options.lineLengthPerDepth=[5,1]] - Number of components
   * per line at a given depth. Valid values: 1 - Infinity.
   * @param {Number} [options.actionMenuButtonSize] - The size of each action menu button.
   */
  constructor(pluginData, resources = null, events = {
    SelectEvent: null,
    UpdateEvent: null,
  }, rootId = &apos;root&apos;, options = {}) {
    /**
     * Plugin data storage.
     * @type {DefaultData}
     */
    this.pluginData = pluginData;
    /**
     * Id of HTML element where we want to draw.
     * @type {String}
     */
    this.rootId = rootId;
    /**
     * Object that contains resources.
     * @type {Object}
     */
    this.resources = resources;
    /**
     * Render svg viewbox width.
     * @type {Number}
     */
    this.width = options.width !== undefined ? options.width : 1280;
    /**
     * Render svg viewbox height.
     * @type {Number}
     */
    this.height = options.height !== undefined ? options.height : 1280;
    /**
     * Minimum width of a component.
     * @type {Number}
     */
    this.minWidth = options.minWidth !== undefined ? options.minWidth : 230;
    /**
     * Minimum height of a component.
     * @type {Number}
     */
    this.minHeight = options.minHeight !== undefined ? options.minHeight : 50;
    /**
     * Padding around components.
     * @type {Number}
     */
    this.padding = options.padding !== undefined ? options.padding : 30;
    /**
     * Component margin thickness.
     * @type {Number}
     */
    this.margin = options.margin !== undefined ? options.margin : 6;
    /**
     * Number of components per line at a given depth. Valid values: 1 - Infinity.
     * @type {Number[]}
     */
    this.lineLengthPerDepth = options.lineLengthPerDepth !== undefined
      ? options.lineLengthPerDepth : [5, 1];

    /**
     * The size of each action menu button.
     * @type {Number}
     */
    this.actionMenuButtonSize = options.actionMenuButtonSize || 24;
    /**
     * Store for actions, used to set specific actions values when making actions.
     * @type {Object}
     */
    this.actions = {
      selection: {
        current: null,
        style: &apos;2px solid hsl(205, 100%, 50%)&apos;,
        offset: &apos;3px&apos;,
      },
      linkCreation: {
        source: null,
        target: null,
        creating: false,
      },
      drag: {
        offsetX: 0,
        offsetY: 0,
        state: false,
        target: null,
      },
    };

    this.setEvents(events);
  }

  /**
   * Convert screen coordinates into a given svg referential.
   * @param {Number} screenX - Screen x coordinate.
   * @param {Number} screenY - Screen y coordinate.
   * @param {SVGSVGElement} [svg=null] - SVG referential.
   * @return {DOMPoint} - The transformed coordinates.
   */
  screenToSVG(screenX, screenY, svg = null) {
    const localSvg = svg || this.svg.node();
    const pivotPoint = new DOMPoint(screenX, screenY);

    return pivotPoint.matrixTransform(localSvg.getScreenCTM().inverse());
  }

  /**
   * Convert svg coordinates into screen coordinates.
   * @param {Number} svgX - SVG x coordinate.
   * @param {Number} svgY - SVG y coordinate.
   * @param {SVGSVGElement} [svg=null] - SVG referential.
   * @return {DOMPoint} - The transformed coordinates.
   */
  SVGToScreen(svgX, svgY, svg = null) {
    const localSvg = svg || this.svg.node();
    const pivotPoint = new DOMPoint(svgX, svgY);

    return pivotPoint.matrixTransform(localSvg.getScreenCTM());
  }

  /**
   * Set events.
   * @param {Function} [events.SelectEvent.next] - Function to emit selection event.
   * @param {Function} [events.UpdateEvent.next] - Function to emit update event.
   */
  setEvents(events = {
    SelectEvent: null,
    UpdateEvent: null,
  }) {
    this.events = {
      SelectEvent: events.SelectEvent || null,
      UpdateEvent: events.UpdateEvent || null,
    };
  }

  /**
   * Emit UpdateEvent if defined.
   */
  emitUpdateEvent() {
    // TODO: replace by: if (this.events?.UpdateEvent) {
    if (this.events &amp;&amp; this.events.UpdateEvent) {
      this.events.UpdateEvent.next();
    }
  }

  /**
   * Compute a coefficient representing how tall a component will be based on its children&apos;s layout.
   * @param {Node} item - The component to check.
   * @return {Number} - The coefficient.
   * @private
   */
  __getVerticalCoefficient(item) {
    // TODO: replace by: if (item.children?.length &gt; 0) {
    if (item.children &amp;&amp; item.children.length &gt; 0) {
      const childHeights = Math.ceil(
        item.children
          // TODO: replace by: .filter((child) =&gt; child.data?.definition?.isContainer)
          .filter((child) =&gt; child
            &amp;&amp; child.data
            &amp;&amp; child.data.definition
            &amp;&amp; child.data.definition.isContainer)
          .reduce(
            (acc, child) =&gt; acc + this.__getVerticalCoefficient(child),
            0,
          ),
      );
      const localChildValue = item.children
        // TODO: replace by: .filter((child) =&gt; !child.data?.definition?.isContainer)
        .filter((child) =&gt; !(child
          &amp;&amp; child.data
          &amp;&amp; child.data.definition
          &amp;&amp; child.data.definition.isContainer))
        .reduce((acc, child) =&gt; acc + child.value, 0);

      return localChildValue / this.getLineLengthForDepth(item.depth)
        + childHeights
        // TODO: replace by: + (item.data?.definition?.isContainer ? 1 : 0);
        + ((item.data
          &amp;&amp; item.data.definition
          &amp;&amp; item.data.definition.isContainer)
          ? 1 : 0);
    }

    return item.value / this.getLineLengthForDepth(item.depth)
      // TODO: replace by: + (item.data?.definition?.isContainer ? 1 : 0);
      + ((item.data
        &amp;&amp; item.data.definition
        &amp;&amp; item.data.definition.isContainer)
        ? 1 : 0);
  }

  /**
   * Get the maximum line length for a given depth.
   * @param {Number} [depth] - The depth to check.
   * @return {Number} - The maximum length at that depth.
   */
  getLineLengthForDepth(depth) {
    return this.lineLengthPerDepth[Math.min(depth, this.lineLengthPerDepth.length - 1)];
  }

  /**
   * Apply the disabled style to all elements matching the selector.
   * @param {String} [selector=&apos;.component&apos;] - CSS selector string.
   */
  setDisabledStyle(selector = &apos;.component&apos;) {
    const localSelector = `#${this.rootId} ${selector || &apos;.component&apos;}`;

    d3.selectAll(localSelector)
      .classed(&apos;disabled&apos;, true);
  }

  /**
   * Remove the disabled style from previously disabled components.
   */
  unsetAllDisabledStyles() {
    d3.selectAll(`#${this.rootId} .disabled`)
      .classed(&apos;disabled&apos;, false);
  }

  /**
   * Handles dragging a component across the screen and return the element it will be dropped on.
   * @param {Element} draggedElement - The DOM element being dragged.
   * @param {DragEvent} event - The emitted drag event.
   * @return {Element} - The element to drop the dragged element onto.
   */
  dragHandler(draggedElement, event) {
    this.hideActionMenu();

    const dropTarget = document
      .elementsFromPoint(event.sourceEvent.x, event.sourceEvent.y)
      .find((element) =&gt; event.subject.data.id !== element.dataset.parentId &amp;&amp; (
        element.classList.contains(&apos;container-background&apos;)
        || element.classList.contains(&apos;container&apos;)
      ));

    const target = d3.select(`#${event.subject.data.id}`).attr(&apos;cursor&apos;, &apos;grabbing&apos;);

    d3.select(&apos;#root-components&apos;)
      .append(() =&gt; target.node());

    const rootSVGPoint = this.screenToSVG(
      event.sourceEvent.clientX,
      event.sourceEvent.clientY,
      this.svg.select(&apos;.container&apos;).node(),
    );

    d3.select(draggedElement)
      .attr(
        &apos;transform&apos;,
        event.subject.transform = `translate(${rootSVGPoint.x - this.actions.drag.offsetX},
        ${rootSVGPoint.y - this.actions.drag.offsetY})`,
      );

    event.subject.x = rootSVGPoint.x - this.actions.drag.offsetX;
    event.subject.y = rootSVGPoint.y - this.actions.drag.offsetY;
    if (event.subject.data.definition) {
      const forbiddenTypes = event.subject.data.definition.parentTypes
        .map((type) =&gt; `:not(.${type})`)
        .join(&apos;&apos;);

      this.setDisabledStyle(`.component:not(#${event.subject.data.id})${forbiddenTypes}`);
    }

    this.drawLinks();

    return dropTarget;
  }

  /**
   * Create and return d3 drag behaviour.
   * @return {Function} - D3 drag behaviour.
   */
  setupDragBehavior() {
    let dropTarget = null;
    let itemWasDragged = false;
    const dragHandler = this.dragHandler.bind(this);

    return d3.drag()
      .subject((event) =&gt; {
        const target = document.elementFromPoint(event.sourceEvent.x, event.sourceEvent.y);
        const targetData = d3.select(target);

        return targetData.datum();
      })
      .on(&apos;start&apos;, (event) =&gt; {
        this.actions.drag.offsetX = event.x - event.subject.x0;
        this.actions.drag.offsetY = event.y - event.subject.y0;
      })
      .on(&apos;drag&apos;, function dragged(event) {
        dropTarget = dragHandler(this, event);
        itemWasDragged = true;
      })
      .on(&apos;end&apos;, (event) =&gt; {
        if (itemWasDragged) {
          this.handleDropEvent(event, dropTarget);
        }
      });
  }

  /**
   * Starting from a given node, recursively mark all parent nodes as needing a resize.
   * @param {Node} node - The node to start from.
   * @private
   */
  __markAsNeedingResize(node) {
    if (node.data.drawOption) {
      node.data.drawOption.needsResizing = true;
    }
    if (node.parent) {
      this.__markAsNeedingResize(node.parent);
    }
  }

  /**
   * Update component hierarchy and re-render.
   * @param {DragEvent} event - D3&apos;s drag event.
   * @param {Element} dropTarget - The element on which the dragged component was dropped.
   */
  handleDropEvent(event, dropTarget) {
    const origParent = this.pluginData.getComponentById(event.subject.parent.data.id);
    const target = dropTarget ? d3.select(dropTarget) : null;

    if (target === origParent) {
      const { x, y } = event.subject;
      const width = event.subject.x1 - event.subject.x0;
      const height = event.subject.y1 - event.subject.y0;

      event.subject.data.drawOption = new ComponentDrawOption({
        x, y, width, height,
      });
    } else {
      if (event.subject.parent) {
        this.__markAsNeedingResize(event.subject.parent);
      }
      event.subject.data.drawOption = null;

      if (target) {
        const parentId = target.attr(&apos;data-parentId&apos;);
        const newParent = this.pluginData.getComponentById(parentId);
        const newParentNode = d3.select(`#${parentId}`).datum();

        if (newParent.definition.childrenTypes.includes(event.subject.data.definition.type)) {
          event.subject.data.setReferenceAttribute(newParent);
          this.__markAsNeedingResize(newParentNode);
        }
      } else {
        event.subject.data.removeAllReferenceAttributes();
      }
    }

    this.emitUpdateEvent();
    this.draw(this.rootId);
  }

  /**
   * Create a new svg to render the models in, or fetch an existing one.
   */
  createRenderingContext() {
    const contextIsPresent = !d3.select(`#${this.rootId}&gt;svg`).empty();

    if (!contextIsPresent) {
      this.svg = d3.select(`#${this.rootId}`)
        .append(&apos;svg&apos;)
        .attr(&apos;viewBox&apos;, [0, 0, this.width, this.height])
        .attr(&apos;preserveAspectRatio&apos;, &apos;xMinYMin meet&apos;)
        .style(&apos;font&apos;, &apos;10px sans-serif&apos;);
      this.svg.append(&apos;g&apos;)
        .attr(&apos;class&apos;, &apos;container&apos;)
        .attr(&apos;height&apos;, &apos;100%&apos;)
        .attr(&apos;width&apos;, &apos;100%&apos;)
        .attr(&apos;x&apos;, 0)
        .attr(&apos;y&apos;, 0);
    } else {
      this.svg = d3.select(`#${this.rootId}`)
        .select(&apos;svg&apos;);
    }
  }

  /**
   * Draws all Components and ComponentLinks in the parentId Element.
   * @param {String} rootId - Id of the container where you want to draw.
   */
  draw(rootId) {
    this.rootId = rootId;
    this.createRenderingContext();

    this.__unselectComponent();

    this.drawComponents();

    this.drawLinks();

    this.setViewPortAction(d3.select(`#${this.rootId}`));
  }

  /**
   * Handle component click event. Set selected style on it.
   * @param {PointerEvent} event - The click event.
   */
  clickHandler(event) {
    event.stopPropagation();
    this.__selectComponent(d3.select(event.currentTarget));
  }

  /**
   * Render components in model view.
   */
  drawComponents() {
    this.shadowRoot = { children: this.pluginData.components, id: &apos;__shadowRoot&apos;, name: &apos;&apos; };
    const groupedNodes = this.buildTree();
    const clicked = this.clickHandler.bind(this);
    const drag = this.setupDragBehavior();
    const node = this.svg
      .select(&apos;.container&apos;)
      .selectAll(&apos;g&apos;)
      .data(groupedNodes, (data) =&gt; data)
      .join(&apos;g&apos;)
      .attr(&apos;id&apos;, ([data]) =&gt; data)
      .selectAll(&apos;g&apos;)
      .data(([, data]) =&gt; data)
      .join(&apos;g&apos;)
      .attr(&apos;id&apos;, ({ data }) =&gt; data.id)
      .on(&apos;click&apos;, clicked)
      .call(drag)
      .attr(&apos;x&apos;, ({ x0 }) =&gt; x0)
      .attr(&apos;y&apos;, ({ y0 }) =&gt; y0)
      .attr(&apos;transform&apos;, ({ x0, y0 }) =&gt; `translate(${x0},${y0})`);

    node
      .filter(({ data }) =&gt; data.id !== &apos;__shadowRoot&apos;)
      .attr(&apos;class&apos;, ({ data }) =&gt; `component
        component-${data.definition.model}
        ${data.definition.type}`)
      .html(({ data }) =&gt; nunjucks.renderString(
        this.resources.models[data.definition.model],
        data,
      ))
      .select(&apos;svg&apos;)
      .attr(&apos;id&apos;, ({ data }) =&gt; `svg-${data.id}`)
      .attr(&apos;height&apos;, ({ y0, y1 }) =&gt; y1 - y0)
      .attr(&apos;width&apos;, ({ x0, x1 }) =&gt; x1 - x0);

    node.select(&apos;.component-icon&apos;)
      .html(({ data }) =&gt; this.resources.icons[data.definition.icon]);

    node.select(&apos;rect&apos;)
      // TODO replace by: .filter((d) =&gt; d.data?.definition?.isContainer)
      .filter((d) =&gt; d.data
        &amp;&amp; d.data.definition
        &amp;&amp; d.data.definition.isContainer)
      .attr(&apos;height&apos;, ({ y0, y1 }) =&gt; y1 - y0)
      .attr(&apos;width&apos;, ({ x0, x1 }) =&gt; x1 - x0);

    node.select(&apos;.component-container&apos;)
      .attr(&apos;height&apos;, ({ y0, y1 }) =&gt; Math.max(
        y1 - (y0 + this.minHeight) - this.margin,
        this.minHeight,
      ))
      .attr(&apos;width&apos;, ({ x0, x1 }) =&gt; Math.max(x1 - x0 - 2 * this.margin, this.minWidth))
      .attr(&apos;x&apos;, () =&gt; this.margin)
      .attr(&apos;y&apos;, () =&gt; this.minHeight)
      .filter(({ children }) =&gt; children)
      .append(({ data }) =&gt; d3.select(`#group-${data.id}`).node());

    node.select(&apos;.component-container&gt;rect&apos;).attr(&apos;data-parentId&apos;, ({ data }) =&gt; data.id);
  }

  /**
   * Build d3 hierarchy and treemap layout.
   * @return {[String, Node[]][]} - The nodes grouped by parent.
   */
  buildTree() {
    const treemapLayout = d3.treemap()
      .size([this.width, this.height])
      .tile((data) =&gt; {
        const lines = this.__buildLines(data);

        this.setupTiles(lines);
        // TODO save/load coordinates
      })
      .round(true);
    const rootNode = d3.hierarchy(
      this.shadowRoot,
      ({ id }) =&gt; this.pluginData.getChildren(id === &apos;__shadowRoot&apos; ? null : id),
    );

    rootNode
      .count()
      .sort((a, b) =&gt; (b.height - a.height)
        || (b.value - a.value)
        || ((b.data &amp;&amp; b.data.definition &amp;&amp; b.data.definition.isContainer ? 1 : 0)
          - (a.data &amp;&amp; a.data.definition &amp;&amp; a.data.definition.isContainer ? 1 : 0))
        || ((a.data &amp;&amp; a.data.drawOption ? 1 : 0)
          - (b.data &amp;&amp; b.data.drawOption ? 1 : 0)));
    /* TODO replace above by: || (b.data.definition?.isContainer || 0)
            - (a.data.definition?.isContainer || 0)); */

    treemapLayout(rootNode);

    return d3.groups(
      rootNode,
      ({ parent }) =&gt; (parent
      &amp;&amp; parent.data.id !== &apos;__shadowRoot&apos;
        ? `group-${parent.data.id}`
        : &apos;root-components&apos;),
    ).filter(([data]) =&gt; data !== &apos;root-__shadowRoot&apos;);
  }

  /**
   * Get the most appropriate anchor point for a link towards the given target.
   * @param {Selection} sourceSelection - The source D3 selection object.
   * @param {Selection} targetSelection - The target D3 selection object.
   * @return {Number[]|null} - Tuple representing x,y coordinates,
   * null if lacking source and/or target. Format required by d3.
   */
  getAnchorPoint(sourceSelection, targetSelection) {
    if (sourceSelection.empty() || targetSelection.empty()) {
      return null;
    }

    const sourceCoords = sourceSelection.node().getBoundingClientRect();
    const sourceCenter = this.getSelectionCenter(sourceSelection);
    const targetCenter = this.getSelectionCenter(targetSelection);

    const angle = this.getBearing(
      this.screenToSVG(sourceCenter.x, sourceCenter.y, this.svg.select(&apos;.container&apos;).node()),
      this.screenToSVG(targetCenter.x, targetCenter.y, this.svg.select(&apos;.container&apos;).node()),
    );

    const topAnchor = {
      y: sourceCoords.top,
      x: sourceCoords.x + (sourceCoords.width / 2),
    };
    const bottomAnchor = {
      y: sourceCoords.bottom,
      x: sourceCoords.x + (sourceCoords.width / 2),
    };
    const leftAnchor = {
      x: sourceCoords.left,
      y: sourceCoords.top + (sourceCoords.height / 2),
    };
    const rightAnchor = {
      x: sourceCoords.right,
      y: sourceCoords.top + (sourceCoords.height / 2),
    };
    let anchorPoint;

    if (angle &lt; 45 || angle &gt;= 315) {
      anchorPoint = bottomAnchor;
    } else if (angle &gt;= 45 &amp;&amp; angle &lt; 135) {
      anchorPoint = rightAnchor;
    } else if (angle &gt;= 135 &amp;&amp; angle &lt; 225) {
      anchorPoint = topAnchor;
    } else {
      anchorPoint = leftAnchor;
    }

    const { x, y } = this.screenToSVG(anchorPoint.x, anchorPoint.y);

    return [x, y];
  }

  /**
   * Render links in model view.
   */
  drawLinks() {
    const pluginLinks = this.pluginData.getLinks();

    if (!pluginLinks) {
      return;
    }

    const links = this.svg
      .selectAll(&apos;.link&apos;);

    links.data(pluginLinks, (data) =&gt; data)
      .join(&apos;path&apos;)
      .filter(({ source, target }) =&gt; !d3.select(`#${source}`).empty()
        &amp;&amp; !d3.select(`#${target}`).empty())
      .classed(&apos;link&apos;, true)
      .attr(&apos;d&apos;, (link) =&gt; {
        const generator = this.getLinkGenerator(link);

        return generator(link);
      })
      .attr(&apos;fill&apos;, &apos;none&apos;)
      .attr(&apos;stroke&apos;, (link) =&gt; link.definition.color)
      .attr(&apos;stroke-width&apos;, (link) =&gt; link.definition.width)
      .attr(&apos;stroke-dasharray&apos;, (link) =&gt; link.definition.dashStyle || &apos;none&apos;)
      .attr(&apos;cursor&apos;, &apos;pointer&apos;)
      .on(&apos;click&apos;, (event) =&gt; this.clickHandler(event));

    links.raise();
  }

  /**
   * Get the coordinates for a given selection&apos;s center.
   * @param {Selection} selection - The selection to find the center for.
   */
  getSelectionCenter(selection) {
    const box = selection.node().getBoundingClientRect();

    return {
      x: box.left + (box.width / 2),
      y: box.top + (box.height / 2),
    };
  }

  /**
   * Get the angle (in degrees) between two points.
   * 0 = pointB is directly below.
   * 180 = pointB is directly above.
   * @param {Object} pointA - The point to get the bearing from.
   * @param {Object} pointB - The point to get the bearing to.
   * @return {Number} - The bearing.
   */
  getBearing(pointA, pointB) {
    const distanceXBA = pointB.x - pointA.x;
    const distanceYBA = pointB.y - pointA.y;
    const x = distanceXBA / (Math.sqrt(distanceXBA ** 2 + distanceYBA ** 2));
    const y = distanceYBA / (Math.sqrt(distanceXBA ** 2 + distanceYBA ** 2));

    return ((Math.atan2(x, y) * (180 / Math.PI)) + 360) % 360;
  }

  /**
   * Build a new d3 link generator for a ComponentLink
   * @param {ComponentLink} link - The link to build the generator for.
   * @returns {Object} - A d3 link generator.
   */
  getLinkGenerator(link) {
    const source = d3.select(`#${link.source}`);
    const target = d3.select(`#${link.target}`);

    const sourceAnchor = this.getAnchorPoint(source, target);
    const targetAnchor = this.getAnchorPoint(target, source);

    const sourceCenter = this.getSelectionCenter(source);
    const targetCenter = this.getSelectionCenter(target);

    const angle = this.getBearing(
      this.screenToSVG(sourceCenter.x, sourceCenter.y, this.svg.select(&apos;.container&apos;).node()),
      this.screenToSVG(targetCenter.x, targetCenter.y, this.svg.select(&apos;.container&apos;).node()),
    );

    let curve;

    if (angle &lt; 45 || angle &gt;= 315 || (angle &gt;= 135 &amp;&amp; angle &lt; 225)) {
      curve = d3.curveBumpY;
    } else {
      curve = d3.curveBumpX;
    }

    return d3.link(curve)
      .source(() =&gt; sourceAnchor)
      .target(() =&gt; targetAnchor);
  }

  /**
   * Compute the dimension of every component.
   * @param {Array} lines - Rows of components.
   */
  setupTiles(lines) {
    let previousTallestItem = { x1: 0, y1: 0 };

    lines.forEach((line, lineIndex) =&gt; {
      let prevItem = {
        x1: 0,
        y0: lineIndex * this.minHeight + this.padding,
      };

      line.items.forEach((item) =&gt; {
        if (item.data.drawOption) {
          item.x0 = item.data.drawOption.x;
          item.y0 = item.data.drawOption.y;
        } else {
          item.x0 = prevItem.x1 + this.padding;
          item.y0 = previousTallestItem.y1 + this.padding;
          prevItem = item;
        }

        if (!item.data.drawOption || item.data.drawOption.needsResizing) {
          /*
           item.depth and item.height are set by d3 and represent the position of the node in
           the hierarchy:
           - height: how many layers exist below this node;
           - depth: how deep in the tree the node is
           */
          const horizontalCoefficient = Math.min(
            item.value,
            this.getLineLengthForDepth(item.depth),
          );
          const verticalCoefficient = Math.ceil(this.__getVerticalCoefficient(item));

          item.x1 = item.x0 + (horizontalCoefficient * (this.minWidth + 2 * this.margin))
            + (item.height * 2 * this.padding)
            + (horizontalCoefficient - 1)
            * (this.padding + 2 * this.margin);

          item.y1 = item.y0
            + (verticalCoefficient * this.minHeight)
            + (item.height * this.padding)
            + (verticalCoefficient - 1)
            * (this.padding + this.margin);

          if (item.data.drawOption) {
            item.data.drawOption.needsResizing = false;
            item.data.drawOption.width = item.x1 - item.x0;
            item.data.drawOption.height = item.y1 - item.y0;
          }
        } else {
          item.x1 = item.x0 + item.data.drawOption.width;
          item.y1 = item.y0 + item.data.drawOption.height;
        }
      });
      if (line.items.length &gt; 0) {
        const maxLineValue = Math.max(...line.items.map((item) =&gt; item.value));

        previousTallestItem = line.items.find((item) =&gt; item.value === maxLineValue);
      }
    });
  }

  /**
   * Build and fill the layout lines for a Node.
   * @param {Node} data - The Node to build lines for.
   * @return {[{total: number, items: Node[]}]} - A list of lines.
   * @private
   */
  __buildLines({ children, depth }) {
    const lines = [{ total: 0, items: [] }];
    let activeLineIndex = 0;
    let activeLine = lines[activeLineIndex];

    children.forEach((child) =&gt; {
      if (activeLine.items.length &gt;= this.getLineLengthForDepth(depth)) {
        lines.push({ total: 0, items: [] });
        activeLineIndex += 1;
      }
      activeLine = lines[activeLineIndex];
      activeLine.total += child.value;
      activeLine.items.push(child);
    });

    return lines;
  }

  /**
   * Set actions on viewport.
   * @param {Object} element - D3 element related to the actions.
   */
  setViewPortAction(element) {
    this.svg.on(&apos;click&apos;, () =&gt; {
      this.__unselectComponent();
      this.cancelLinkCreationInteraction();
    });
    const drawLinks = this.drawLinks.bind(this);

    element.call(d3
      .zoom()
      .on(&apos;zoom&apos;, function zoomHandler(event) {
        d3.select(this).select(&apos;.container&apos;).attr(&apos;transform&apos;, event.transform);
        drawLinks();
      }));
  }

  /**
   * Action to unselect current element.
   * If no element is selected, does nothing.
   * @private
   */
  __unselectComponent() {
    if (this.actions.selection.current) {
      d3.select(`#${this.rootId} .selected`)
        .classed(&apos;selected&apos;, false)
        .style(&apos;outline&apos;, &apos;&apos;);
      this.actions.selection.current = null;
      this.hideActionMenu();
    }
  }

  /**
   * Unselects current selected element and selects a new one.
   * @param {Selection} targetSelection - Component or link to select.
   * @private
   */
  __selectComponent(targetSelection) {
    const currentComponent = targetSelection.datum().__class === &apos;Link&apos;
      ? targetSelection.datum()
      : targetSelection.datum().data;
    const sameElementClicked = this.actions.selection.current === currentComponent;

    if (this.actions.linkCreation.creating) {
      if (targetSelection.node().classList.contains(&apos;disabled&apos;)) {
        return;
      }

      this.actions.linkCreation.target = currentComponent;
      this.createLink();
    } else {
      this.__unselectComponent();

      if (sameElementClicked) {
        return;
      }

      targetSelection
        .classed(&apos;selected&apos;, true)
        .style(&apos;outline&apos;, this.actions.selection.style)
        .style(&apos;outline-offset&apos;, this.actions.selection.offset);
      this.actions.selection.current = currentComponent;

      // TODO: replace by: if (this.events?.SelectEvent &amp;&amp; (...)) {
      if (this.events &amp;&amp; this.events.SelectEvent &amp;&amp; currentComponent.__class === &apos;Component&apos;) {
        this.events.SelectEvent.next(currentComponent);
      }

      this.initializeActionMenu(targetSelection);
    }
  }

  /**
   * Create a link between the previously selected source and destination.
   */
  createLink() {
    const { source, target } = this.actions.linkCreation;
    const activeLinkType = this.pluginData.definitions.links
      .find((definition) =&gt; definition.sourceRef === source.definition.type
        &amp;&amp; definition.targetRef === target.definition.type);

    const newLink = new ComponentLink({
      source: source.id,
      target: target.id,
      definition: activeLinkType,
    });

    this.actions.linkCreation.source.setLinkAttribute(newLink);

    this.emitUpdateEvent();

    this.cancelLinkCreationInteraction();

    this.drawLinks();
  }

  /**
   * Initialize the action menu for a given target.
   * @param {Selection} targetSelection - D3 selection of the target object.
   */
  initializeActionMenu(targetSelection) {
    const actionMenu = this.svg
      .select(&apos;.container&apos;)
      .append(&apos;svg&apos;)
      .attr(&apos;id&apos;, &apos;action-menu&apos;);

    const actions = this.getMenuActions(targetSelection);

    const zoomTransform = d3.zoomTransform(this.svg.select(&apos;.container&apos;).node());

    actionMenu
      .append(&apos;rect&apos;)
      .attr(&apos;fill&apos;, &apos;lightgrey&apos;)
      .attr(&apos;width&apos;, this.actionMenuButtonSize * actions.length)
      .attr(&apos;height&apos;, this.actionMenuButtonSize)
      .attr(&apos;rx&apos;, 5);

    const { bottom, width, left } = targetSelection.node().getBoundingClientRect();
    const { x, y } = this.screenToSVG(
      (left + (width / 2)) - ((this.actionMenuButtonSize * actions.length) / 2) * zoomTransform.k,
      bottom + 20,
      this.svg.select(&apos;.container&apos;).node(),
    );

    actionMenu
      .attr(&apos;x&apos;, x)
      .attr(&apos;y&apos;, y);

    const buttons = actionMenu
      .selectAll(&apos;svg&apos;)
      .data(actions)
      .join(&apos;svg&apos;)
      .attr(&apos;id&apos;, (data) =&gt; data.id)
      .attr(&apos;width&apos;, this.actionMenuButtonSize)
      .attr(&apos;height&apos;, this.actionMenuButtonSize)
      .attr(&apos;x&apos;, (_d, index) =&gt; (this.actionMenuButtonSize * index))
      .attr(&apos;preserveAspectRatio&apos;, &apos;xMinYMin meet&apos;)
      .attr(&apos;cursor&apos;, &apos;pointer&apos;)
      .on(&apos;click&apos;, (event, data) =&gt; {
        event.stopPropagation();
        const handler = data.handler.bind(this);

        handler(event, data);
      });

    buttons
      .append(&apos;rect&apos;)
      .classed(&apos;bg-button&apos;, true)
      .attr(&apos;fill&apos;, &apos;lightgrey&apos;)
      .attr(&apos;rx&apos;, 5)
      .style(&apos;width&apos;, this.actionMenuButtonSize)
      .style(&apos;height&apos;, this.actionMenuButtonSize);

    buttons
      .on(&apos;mouseenter&apos;, function onHover() {
        d3.select(this)
          .select(&apos;.bg-button&apos;)
          .attr(&apos;fill&apos;, &apos;grey&apos;);
      })
      .on(&apos;mouseleave&apos;, function onLeave() {
        d3.select(this)
          .select(&apos;.bg-button&apos;)
          .attr(&apos;fill&apos;, &apos;lightgrey&apos;);
      });

    buttons
      .append(&apos;g&apos;)
      .attr(&apos;x&apos;, 0)
      .attr(&apos;y&apos;, 0)
      .html((d) =&gt; d.icon)
      .select(&apos;svg&apos;)
      .attr(&apos;width&apos;, &apos;80%&apos;)
      .attr(&apos;height&apos;, &apos;80%&apos;)
      .attr(&apos;x&apos;, &apos;10%&apos;)
      .attr(&apos;y&apos;, &apos;10%&apos;);

    actionMenu.selectAll(&apos;button&apos;)
      .style(&apos;width&apos;, &apos;30px&apos;)
      .style(&apos;height&apos;, &apos;30px&apos;)
      .style(&apos;border&apos;, &apos;none&apos;);
  }

  /**
   * Store new link source and apply disabled style to invalid target components.
   */
  startLinkCreationInteraction() {
    if (this.actions.selection.current) {
      const source = this.pluginData.getComponentById(this.actions.selection.current.id);
      const allowedLinkTargets = source.definition.definedAttributes
        .filter((a) =&gt; a.type === &apos;Link&apos;);
      const forbiddenTypes = allowedLinkTargets
        .map((linkTarget) =&gt; `:not(.${linkTarget.linkRef})`)
        .join(&apos;&apos;);

      this.actions.linkCreation.creating = true;
      this.actions.linkCreation.source = source;

      this.setDisabledStyle(`.component:not(#${source.id})${forbiddenTypes}`);
    }
  }

  /**
   * Get a list of actions to fill the menu for a given target.
   * @param {Object} targetSelection - The target object.
   * @type {Object}
   * @property {String} id - Id of the action button.
   * @property {String} icon - Icon to display in the action button
   * @property {Function} handler - Function called on action click.
   * @return {MenuActions[]} - The list of menu actions.
   */
  getMenuActions(targetSelection) {
    if (targetSelection.classed(&apos;component&apos;)) {
      return [
        {
          id: &apos;create-link&apos;,
          icon: actionIcons.link,
          handler() {
            this.startLinkCreationInteraction();
          },
        },
        {
          id: &apos;remove-component&apos;,
          icon: actionIcons.trash,
          handler() {
            this.pluginData.removeComponentById(this.actions.selection.current.id);
            this.emitUpdateEvent();
            this.draw(this.rootId);
          },
        },
      ];
    }

    return [
      {
        id: &apos;remove-link&apos;,
        icon: actionIcons.trash,
        handler() {
          this.pluginData.removeLink(this.actions.selection.current);
          this.emitUpdateEvent();
          this.draw(this.rootId);
        },
      },
    ];
  }

  /**
   * Handle link creation being cancelled.
   */
  cancelLinkCreationInteraction() {
    this.actions.linkCreation.creating = false;
    this.actions.linkCreation.source = null;
    this.actions.linkCreation.target = null;
    this.unsetAllDisabledStyles();
  }

  /**
   * Hide the action menu.
   */
  hideActionMenu() {
    d3.select(&apos;#action-menu&apos;)
      .remove();
  }
}
export default DefaultDrawer;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
